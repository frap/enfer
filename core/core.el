;;; core.el --- the heart of the beast -*- lexical-binding: t; -*-

(defvar enfer-init-p nil
  "Non-nil if Enfer has been initialised.")

(defvar enfer-init-time nil
  "The time it took, in seconds, for Enfer Emacs to initialise.")

(defvar enfer-debug-mode (or (getenv "DEBUG") init-file-debug)
  "If non-nil, Enfer will log more.

Use `enfer/toggle-debug-mode' to toggle it. The --debug-init flag and setting the
DEBUG envvar will enable this at startup.")

(defvar enfer-gc-cons-threshold 16777216 ; 16mb
  "The default value to use for `gc-cons-threshold'. If you experience freezing,
decrease this. If you experience stuttering, increase this.")

;;
;;; Constants

(defconst enfer-version "0.0.7"
  "Current version of Enfer Emacs.")

(defconst EMACS26+ (> emacs-major-version 25))
(defconst EMACS27+ (> emacs-major-version 26))

(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
(defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))


;;
(defvar enfer-emacs-dir
  (eval-when-compile (file-truename user-emacs-directory))
  "The path to the currently loaded .emacs.d directory. Must end with a slash.")

(defvar enfer-core-dir (concat enfer-emacs-dir "core/")
  "The root directory of Enfer's core files. Must end with a slash.")

(defvar enfer-modules-dir (concat enfer-emacs-dir "modules/")
  "The root directory for Enfer's modules. Must end with a slash.")

(defvar enfer-local-dir (concat enfer-emacs-dir ".local/")
  "Root directory for local storage.

Use this as a storage location for this system's installation of Enfer Emacs.
These files should not be shared across systems. By default, it is used by
`enfer-etc-dir' and `enfer-cache-dir'. Must end with a slash.")

(defvar enfer-etc-dir (concat enfer-local-dir "etc/")
  "Directory for non-volatile local storage.

Use this for files that don't change much, like server binaries, external
dependencies or long-term shared data. Must end with a slash.")

(defvar enfer-cache-dir (concat enfer-local-dir "cache/")
  "Directory for volatile local storage.

Use this for files that change often, like cache files. Must end with a slash.")

(defvar enfer-packages-dir (concat enfer-local-dir "packages/")
  "Where package.el and quelpa plugins (and their caches) are stored.

Must end with a slash.")

(defvar enfer-docs-dir (concat enfer-emacs-dir "docs/")
  "Where Enfer's documentation files are stored. Must end with a slash.")

(defvar enfer-private-dir
  (or (getenv "ENFERDIR")
      (let ((xdg-path
             (expand-file-name "enfer/"
                               (or (getenv "XDG_CONFIG_HOME")
                                   "~/.config"))))
        (if (file-directory-p xdg-path) xdg-path))
      "~/.enfer.d/")
  "Where your private configuration is placed.

Defaults to ~/.config/enfer, ~/.enfer.d or the value of the ENFERDIR envvar;
whichever is found first. Must end in a slash.")

(defvar enfer-autoload-file (concat enfer-local-dir "autoloads.el")
  "Where `enfer-reload-enfer-autoloads' stores its core autoloads.

This file is responsible for informing Emacs where to find all of Enfer's
autoloaded core functions (in core/autoload/*.el).")

(defvar enfer-package-autoload-file (concat enfer-local-dir "autoloads.pkg.el")
  "Where `enfer-reload-package-autoloads' stores its package.el autoloads.

This file is compiled from the autoloads files of all installed packages
combined.")

(defvar enfer-env-file (concat enfer-local-dir "env")
  "The location of your envvar file, generated by `enfer env refresh`.

This file contains environment variables scraped from your shell environment,
which is loaded at startup (if it exists). This is helpful if Emacs can't
\(easily) be launched from the correct shell session (particularly for MacOS
users).")

(defvar enfer--initial-load-path (cons enfer-core-dir load-path))
(defvar enfer--initial-process-environment process-environment)
(defvar enfer--initial-exec-path exec-path)
(defvar enfer--initial-file-name-handler-alist file-name-handler-alist)

;;
;;; Custom error types

(define-error 'enfer-error "Erreur dans Enfer Emacs core")
(define-error 'enfer-hook-error "Erreur dans un Enfer startup hook" 'enfer-error)
(define-error 'enfer-autoload-error "Erreur dans un autoloads file" 'enfer-error)
(define-error 'enfer-module-error "Erreur dans un Enfer module" 'enfer-error)
(define-error 'enfer-private-error "Erreur dans private config" 'enfer-error)
(define-error 'enfer-package-error "Erreur avec packages" 'enfer-error)


;;
;;; Emacs core configuration

;; Reduce debug output, well, unless we've asked for it.
(setq debug-on-error enfer-debug-mode
      jka-compr-verbose enfer-debug-mode)

;; UTF-8 as the default coding system
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))       ; pretty
(prefer-coding-system 'utf-8)            ; pretty
(setq locale-coding-system 'utf-8)       ; please
;; Except for the clipboard on Windows, where its contents could be in an
;; encoding that's wider than utf-8, so we let Emacs/the OS decide what encoding
;; to use.
(unless IS-WINDOWS
  (setq selection-coding-system 'utf-8)) ; with sugar on top

;; Disable warnings from legacy advice system. They aren't useful, and we can't
;; often do anything about them besides changing packages upstream
(setq ad-redefinition-action 'accept)

;; Make apropos omnipotent. It's more useful this way.
(setq apropos-do-all t)

;; Don't make a second case-insensitive pass over `auto-mode-alist'. If it has
;; to, it's our (the user's) failure. One case for all!
(setq auto-mode-case-fold nil)

;; Enable all disabled commands.
(setq disabled-command-function nil)

;; Display the bare minimum at startup. We don't need all that noise. The
;; dashboard/empty scratch buffer is good enough.
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
(fset #'display-startup-echo-area-message #'ignore)

;; Emacs "updates" its ui more often than it needs to, so we slow it down
;; slightly, from 0.5s:
(setq idle-update-delay 1)

;; Emacs is a huge security vulnerability, what with all the dependencies it
;; pulls in from all corners of the globe. Let's at least try to be more
;; discerning.
(setq gnutls-verify-error (not (getenv "INSECURE"))
      tls-checktrust gnutls-verify-error
      tls-program '("gnutls-cli --x509cafile %t -p %p %h"
                    ;; compatibility fallbacks
                    "gnutls-cli -p %p %h"
                    "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof"))

;; Emacs stores authinfo in HOME and in plaintext. Let's not do that, mkay? This
;; file usually stores usernames, passwords, and other such treasures for the
;; aspiring malicious third party.
(setq auth-sources (list (expand-file-name "authinfo.gpg" enfer-etc-dir)
                         "~/.authinfo.gpg"))

;; Emacs on Windows frequently confuses HOME (C:\Users\<NAME>) and APPDATA,
;; causing `abbreviate-home-dir' to produce incorrect paths.
(when IS-WINDOWS
  (setq abbreviated-home-dir "\\`'"))

;; Don't litter `enfer-emacs-dir'
(setq abbrev-file-name             (concat enfer-local-dir "abbrev.el")
      async-byte-compile-log-file  (concat enfer-etc-dir "async-bytecomp.log")
      bookmark-default-file        (concat enfer-etc-dir "bookmarks")
      custom-file                  (concat enfer-private-dir "init.el")
      custom-theme-directory       (concat enfer-private-dir "themes/")
      desktop-dirname              (concat enfer-etc-dir "desktop")
      desktop-base-file-name       "autosave"
      desktop-base-lock-name       "autosave-lock"
      pcache-directory             (concat enfer-cache-dir "pcache/")
      request-storage-directory    (concat enfer-cache-dir "request")
      server-auth-dir              (concat enfer-cache-dir "server/")
      shared-game-score-directory  (concat enfer-etc-dir "shared-game-score/")
      tramp-auto-save-directory    (concat enfer-cache-dir "tramp-auto-save/")
      tramp-backup-directory-alist backup-directory-alist
      tramp-persistency-file-name  (concat enfer-cache-dir "tramp-persistency.el")
      url-cache-directory          (concat enfer-cache-dir "url/")
      url-configuration-directory  (concat enfer-etc-dir "url/")
      gamegrid-user-score-file-directory (concat enfer-etc-dir "games/"))


;;
;;; Optimizations

;; Disable bidirectional text rendering for a modest performance boost. Of
;; course, this renders Emacs unable to detect/display right-to-left languages
;; (sorry!), but for us left-to-right language speakers/writers, it's a boon.
(setq-default bidi-display-reordering 'left-to-right)

;; Reduce rendering/line scan work for Emacs by not rendering cursors or regions
;; in non-focused windows.
(setq-default cursor-in-non-selected-windows nil)
(setq highlight-nonselected-windows nil)

;; More performant rapid scrolling over unfontified regions. May cause brief
;; spells of inaccurate fontification immediately after scrolling.
(setq fast-but-imprecise-scrolling t)

;; Resizing the Emacs frame can be a terribly expensive part of changing the
;; font. By inhibiting this, we easily halve startup times with fonts that are
;; larger than the system default.
(setq frame-inhibit-implied-resize t)

;; Don't ping things that look like domain names.
(setq ffap-machine-p-known 'reject)

;; Performance on Windows is considerably worse than elsewhere. We'll need
;; everything we can get.
(when IS-WINDOWS
  ;; Reduce the workload when doing file IO
  (setq w32-get-true-file-attributes nil)

  ;; Font compacting can be terribly expensive, especially for rendering icon
  ;; fonts on Windows. Whether it has a noteable affect on Linux and Mac hasn't
  ;; been determined.
  (setq inhibit-compacting-font-caches t))

;; Remove command line options that aren't relevant to our current OS; that
;; means less to process at startup.
(unless IS-MAC   (setq command-line-ns-option-alist nil))
(unless IS-LINUX (setq command-line-x-option-alist nil))

;; This is consulted on every `require', `load' and various path/io functions.
;; You get a minor speed up by nooping this.
(setq file-name-handler-alist nil)

(defun enfer-restore-file-name-handler-alist-h ()
  (setq file-name-handler-alist enfer--initial-file-name-handler-alist))

(add-hook 'emacs-startup-hook #'enfer-restore-file-name-handler-alist-h)

;; To speed up minibuffer commands (like helm and ivy), we defer garbage
;; collection while the minibuffer is active.
(defun enfer-defer-garbage-collection-h ()
  "TODO"
  (setq gc-cons-threshold most-positive-fixnum))

(defun enfer-restore-garbage-collection-h ()
  "TODO"
  ;; Defer it so that commands launched immediately after will enjoy the
  ;; benefits.
  (run-at-time
   1 nil (lambda () (setq gc-cons-threshold enfer-gc-cons-threshold))))

(add-hook 'minibuffer-setup-hook #'enfer-defer-garbage-collection-h)
(add-hook 'minibuffer-exit-hook #'enfer-restore-garbage-collection-h)

;; Not restoring these to their defaults will cause stuttering/freezes.
(add-hook 'emacs-startup-hook #'enfer-restore-garbage-collection-h)

;; When Emacs loses focus seems like a great time to do some garbage collection
;; all sneaky breeky like, so we can return a fresh(er) Emacs.
(add-hook 'focus-out-hook #'garbage-collect)


;;
;;; MODE-local-vars-hook

;; File+dir local variables are initialized after the major mode and its hooks
;; have run. If you want hook functions to be aware of these customizations, add
;; them to MODE-local-vars-hook instead.
(defun enfer-run-local-var-hooks-h ()
  "Run MODE-local-vars-hook after local variables are initialized."
  (run-hook-wrapped (intern-soft (format "%s-local-vars-hook" major-mode))
                    #'enfer-try-run-hook))
(add-hook 'hack-local-variables-hook #'enfer-run-local-var-hooks-h)

;; If `enable-local-variables' is disabled, then `hack-local-variables-hook' is
;; never triggered.
(defun enfer-run-local-var-hooks-if-necessary-h ()
  "Run `enfer-run-local-var-hooks-h' if `enable-local-variables' is disabled."
  (unless enable-local-variables
    (enfer-run-local-var-hooks-h)))
(add-hook 'after-change-major-mode-hook
          #'enfer-run-local-var-hooks-if-necessary-h
          'append)


;;
;;; Incremental lazy-loading

(defvar enfer-incremental-packages '(t)
  "A list of packages to load incrementally after startup. Any large packages
here may cause noticable pauses, so it's recommended you break them up into
sub-packages. For example, `org' is comprised of many packages, and can be
broken up into:

  (enfer-load-packages-incrementally
   '(calendar find-func format-spec org-macs org-compat
     org-faces org-entities org-list org-pcomplete org-src
     org-footnote org-macro ob org org-clock org-agenda
     org-capture))

This is already done by the lang/org module, however.

If you want to disable incremental loading altogether, either remove
`enfer-load-packages-incrementally-h' from `emacs-startup-hook' or set
`enfer-incremental-first-idle-timer' to nil.")

(defvar enfer-incremental-first-idle-timer 2
  "How long (in idle seconds) until incremental loading starts.

Set this to nil to disable incremental loading.")

(defvar enfer-incremental-idle-timer 1.5
  "How long (in idle seconds) in between incrementally loading packages.")

(defun enfer-load-packages-incrementally (packages &optional now)
  "Registers PACKAGES to be loaded incrementally.

If NOW is non-nil, load PACKAGES incrementally, in `enfer-incremental-idle-timer'
intervals."
  (if (not now)
      (nconc enfer-incremental-packages packages)
    (when packages
      (let ((gc-cons-threshold most-positive-fixnum)
            (file-name-handler-alist nil)
            (reqs (cl-delete-if #'featurep packages)))
        (when-let (req (if reqs (pop reqs)))
          (enfer-log "Incrementally loading %s" req)
          (condition-case e
              (or (while-no-input (require req nil t) t)
                  (push req reqs))
            ((error debug)
             (message "Failed to load '%s' package incrementally, because: %s"
                      req e)))
          (if reqs
              (run-with-idle-timer enfer-incremental-idle-timer
                                   nil #'enfer-load-packages-incrementally
                                   reqs t)
            (enfer-log "Finished incremental loading")))))))

(defun enfer-load-packages-incrementally-h ()
  "Begin incrementally loading packages in `enfer-incremental-packages'.

If this is a daemon session, load them all immediately instead."
  (if (daemonp)
      (mapc #'require (cdr enfer-incremental-packages))
    (when (integerp enfer-incremental-first-idle-timer)
      (run-with-idle-timer enfer-incremental-first-idle-timer
                           nil #'enfer-load-packages-incrementally
                           (cdr enfer-incremental-packages) t))))

(add-hook 'emacs-startup-hook #'enfer-load-packages-incrementally-h)


;;
;;; Bootstrap helpers

(defun enfer-try-run-hook (hook)
  "Run HOOK (a hook function), but handle errors better, to make debugging
issues easier.

Meant to be used with `run-hook-wrapped'."
  (enfer-log "Running enfer hook: %s" hook)
  (condition-case e
      (funcall hook)
    ((debug error)
     (signal 'enfer-hook-error (list hook e))))
  ;; return nil so `run-hook-wrapped' won't short circuit
  nil)

(defun enfer-display-benchmark-h (&optional return-p)
  "Display a benchmark, showing number of packages and modules, and how quickly
they were loaded at startup.

If RETURN-P, return the message as a string instead of displaying it."
  (funcall (if return-p #'format #'message)
           "Enfer chargée %s pacquets sur %d modules dans %.03fs"
           (- (length load-path) (length enfer--initial-load-path))
           (if enfer-modules (hash-table-count enfer-modules) 0)
           (or enfer-init-time
               (setq enfer-init-time (float-time (time-subtract (current-time) before-init-time))))))


(defun enfer-load-autoloads-file (file)
  "Tries to load FILE (an autoloads file). Return t on success, throws an error
in interactive sessions, nil otherwise (but logs a warning)."
  (condition-case e
      (let (command-switch-alist)
        (load (if noninteractive file (file-name-sans-extension file))
              'noerror 'nomessage))
    ((debug error)
     (if noninteractive
         (message "Autoload avertissement de fichier: %s -> %s" (car e) (error-message-string e))
       (signal 'enfer-autoload-error (list (file-name-nondirectory file) e))))))

(defun enfer-load-envvars-file (file &optional noerror)
  "Read and set envvars in FILE."
  (if (not (file-readable-p file))
      (unless noerror
        (signal 'file-error (list "Couldn't read envvar file" file)))
    (with-temp-buffer
      (insert-file-contents file)
      (search-forward "\n\n" nil t)
      (while (re-search-forward "\n\\([^= \n]+\\)=" nil t)
        (save-excursion
          (let ((var (match-string 1))
                (value (buffer-substring-no-properties
                        (point)
                        (1- (or (when (re-search-forward "^\\([^= ]+\\)=" nil t)
                                  (line-beginning-position))
                                (point-max))))))
            (setenv var value)))))
    (setq exec-path (append (split-string (getenv "PATH")
                                          (if IS-WINDOWS ";" ":"))
                            (list exec-directory))
          shell-file-name (or (getenv "SHELL")
                              shell-file-name))
    t))

(defun enfer-initialize (&optional force-p)
  "Bootstrap Enfer, if it hasn't already (or if FORCE-P is non-nil).

The bootstrap process involves making sure 1) the essential directories exist,
2) the core packages are installed, 3) `enfer-autoload-file' and
`enfer-package-autoload-file' exist and have been loaded, and 4) Enfer's core
files are loaded.

If the cache exists, much of this function isn't run, which substantially
reduces startup time.

The overall load order of Enfer is as follows:

  ~/.emacs.d/init.el
  ~/.emacs.d/core/core.el
  ~/.enfer.d/init.el
  Module init.el files
  `enfer-before-init-modules-hook'
  Module config.el files
  ~/.enfer.d/config.el
  `enfer-init-modules-hook'
  `after-init-hook'
  `emacs-startup-hook'
  `enfer-init-ui-hook'
  `window-setup-hook'

Module load order is determined by your `enfer!' block. See `enfer-modules-dirs'
for a list of all recognized module trees. Order defines precedence (from most
to least)."
  (when (or force-p (not enfer-init-p))
    (setq enfer-init-p t)

    ;; Reset as much state as possible, so `enfer-initialize' can be treated like
    ;; a reset function. Particularly useful for reloading the config.
    (setq exec-path enfer--initial-exec-path
          load-path enfer--initial-load-path
          process-environment enfer--initial-process-environment)

    (require 'core-lib)
    (require 'core-modules)
    (let (;; `enfer-autoload-file' tells Emacs where to load all its functions
          ;; from. This includes everything in core/autoload/*.el and autoload
          ;; files in enabled modules.
          (core-autoloads-p (enfer-load-autoloads-file enfer-autoload-file))
          ;; Loads `enfer-package-autoload-file', which loads a concatenated
          ;; package autoloads file which caches `load-path', `auto-mode-alist',
          ;; `Info-directory-list', and `enfer-disabled-packages'. A big
          ;; reduction in startup time.
          (pkg-autoloads-p
           (unless noninteractive
             (enfer-load-autoloads-file enfer-package-autoload-file))))

      (if (and core-autoloads-p (not force-p))
          ;; In case we want to use package.el or straight via M-x
          (progn
            (with-eval-after-load 'package
              (require 'core-packages))
            (with-eval-after-load 'straight
              (require 'core-packages)
              (enfer-initialize-packages)))

        ;; Eagerly load these libraries because this module may be loaded in a session
        ;; that hasn't been fully initialized (where autoloads files haven't been
        ;; generated or `load-path' populated).
        (let ((default-directory enfer-core-dir))
          (mapc (enfer-rpartial #'load 'noerror 'nomessage)
                (file-expand-wildcards "autoload/*.el")))

        ;; Create all our core directories to quell file errors
        (dolist (dir (list enfer-local-dir
                           enfer-etc-dir
                           enfer-cache-dir
                           enfer-elpa-dir))
          (unless (file-directory-p dir)
            (make-directory dir 'parents)))

        ;; Ensure the package management system (and straight) are ready for
        ;; action (and all core packages/repos are installed)
        (require 'core-packages)
        (enfer-ensure-straight)
        (enfer-initialize-packages force-p))

      (unless (or (and core-autoloads-p pkg-autoloads-p)
                  force-p
                  noninteractive)
        (unless core-autoloads-p
          (message "Your Enfer core autoloads file is missing"))
        (unless pkg-autoloads-p
          (message "Your package autoloads file is missing"))
        (user-error "Run `bin/enfer refresh' to generate them")))

    ;; Load shell environment, optionally generated from 'enfer env'
    (unless noninteractive
      (when (file-exists-p enfer-env-file)
        (enfer-load-envvars-file enfer-env-file)))))


;;
;;; Bootstrap Enfer

(enfer-initialize noninteractive)
(if noninteractive
    (require 'core-cli)
  (add-hook 'window-setup-hook #'enfer-display-benchmark-h)
  (require 'core-keybinds)
  (require 'core-ui)
  (require 'core-projects)
  (require 'core-editor))

(enfer-initialize-modules)


(provide 'core)
;;; core.el ends here
